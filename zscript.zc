version "4.1.3"

#include "zscript/enemy/CacoBasic.Caco.txt"
#include "zscript/enemy/CacoBasic.PrincipalOfSin.txt"

#include "zscript/CacoBasic.Door.txt"
#include "zscript/CacoBasic.EventHandler.txt"
#include "zscript/CacoBasic.HUD.txt"
#include "zscript/CacoBasic.Player.txt"

//------------- Debug stuff
#include "zscript/RadiusDebug/RadiusDebug.zc" //made by Nash

#include "zscript/pathfinding/navmesh.zc"
#include "zscript/pathfinding/pathfinder.zc"


class NavIndicator : Actor
{
    Default
    {
        Radius 16;
        Height 16;

        RenderStyle "Add";

        +NOGRAVITY
        +NOBLOCKMAP
    }

    States
    {
    Spawn:
        POSS ABCDEFGH 6 Bright
        {
            angle += 10;
        }
        Loop;
    }
}


class NavPoint : Actor
{
    array<NavPoint> links;
    array<double>   costs;

    Default
    {
        Radius 8;
        Height 8;

        +NOBLOCKMAP
        +NOGRAVITY
    }

    override void PostBeginPlay()
    {
        //A_Log("(ZScript:NavPoint) Initializing...");  // DEBUG

        // Connect this NavPoint to every other NavPoint that can be reached without being blocked
        // Note: this means actors will try to walk over bottomless pits, etc.
        // It also means links may go through other Navs
        ThinkerIterator it = ThinkerIterator.Create("NavPoint");
        for (NavPoint nav = NavPoint(it.Next()); nav; nav = NavPoint(it.Next()))
        {
            if (nav == self)
                continue;

            // Commented out because there seem to be some bugs w/ CheckSight
            if (CheckSight(nav))
            {
                links.Push(nav);
                costs.Push(Distance2d(nav));

                A_Log("(ZScript:NavPoint) Link added");    // DEBUG
            }
			
            // Just make sure it's possible to get from one Nav to the other w/o being blocked
            double angle = AngleTo(nav);
            bool passable = true;
            int stepCount = Distance2d(nav)/radius + 1;
            for (int i = 0; i < stepCount; ++i)
            {
                if (CheckBlock(0, AAPTR_DEFAULT, i*radius, 0, 0, angle))
                {
                    passable = false;
                    break;
                }
            }

            if (passable)
            {
                links.Push(nav);
                costs.Push(Distance2d(nav));

                //A_Log("(ZScript:NavPoint) Link added");    // DEBUG
            }
        }

        if (links.Size() == 0)
            A_Log("\c[Yellow](ZScript:NavPoint) Warning: No links created!");

        Super.PostBeginPlay();
    }
}


class Plan2
{
    array<NavPoint> path;   // NavPoints that path passes through
    double givenCost;       // Distance from starting point to last NavPoint in path
    double heuristicCost;   // Approx. distance from last NavPoint to the goal
}

class Pathfinder2 : Actor
{
    array<NavPoint> path;

    Actor navIndicator;

    action void A_Star()
    {
        if (CheckSight(target) && Distance2D(target) < 100)
        {
            invoker.path.Clear();
            goal = null;

            A_Chase();
			
			if (invoker.navIndicator)
				invoker.navIndicator.Destroy();
        }
        else if (NavPoint(goal) && Distance2d(goal) > radius)
        {
			
			if (!invoker.navIndicator)
			{
				invoker.navIndicator = Spawn("navIndicator",goal.pos);
			}

            A_Face(goal);
			int oldDir = moveDir;
			moveDir = (8 * AngleTo(goal, true) / 360) % 8;
			if (!TryWalk())
			{
				moveDir = oldDir;
				if(!TryWalk())
				{
					for (int i = 1; i <= 4; ++i)
					{
						moveDir = (oldDir + i) % 8;
						if (TryWalk())
							break;
			
						moveDir = (oldDir - i) % 8;
						if (TryWalk())
							break;
					}
				}
			}
			
			// Face movement direction
			angle = 360 * moveDir / 8;
			if (angle > 180)
				angle -= 360;
        }
        else if (invoker.path.Size() > 0)
        {
            //A_Log("(ZScript:Pathfinder2:A_Star) NavPoint reached."); // DEBUG

            goal = invoker.path[invoker.path.Size()-1];
            invoker.path.Pop();

            // DEBUG
			if (invoker.navIndicator)
			{
				invoker.navIndicator.A_Remove(AAPTR_DEFAULT, RMVF_EVERYTHING);
				invoker.navIndicator = Spawn("NavIndicator", goal.pos);
			}
        }
        else
        {
            //A_Log("(ZScript:Pathfinder2:A_Star) Plan2ning path..."); // DEBUG

            // Find first and last NavPoints
            // That is, closest Nav in LOS,
            // and closest Nav to target in target's LOS
            // WARNING: LOS doesn't imply a straight-line path, so this is technically broken
            NavPoint startNav, goalNav;

            {
                double startDist = -1.0;
                double goalDist = -1.0;

                ThinkerIterator it = ThinkerIterator.Create("NavPoint");
                NavPoint nav = NavPoint(it.Next());
                for (; nav; nav = NavPoint(it.Next()))
                {
                    double dist = Distance2d(nav);
                    if ((startDist < 0 || dist < startDist) && CheckSight(nav))
                    {
                        startNav = nav;
                        startDist = dist;
                    }

                    dist = target.Distance2d(nav);
                    if ((goalDist < 0 || dist < goalDist) && target.CheckSight(nav))
                    {
                        goalNav = nav;
                        goalDist = dist;
                    }
                }

                if (!(startNav && goalNav))
                {
                    A_Log("\c[Red](ZScript:Pathfinder2:A_Star) Error: NavPoint graph incomplete!");
                    return;
                }
            }

            // Find the shortest path from one to the other using A* search
            {
                // Fringe contains partial Plan2s under consideration
                // In spite of appearances, it's actually a binary min-heap
                // This means that the Plan2 w/ the shortest path is always first
                // It also means that adding/removing elements is complex (see below)
                array<Plan2> fringe;

                // Initial Plan2
                fringe.Push(New('Plan2'));
                fringe[0].path.Push(startNav);
                fringe[0].givenCost = Distance2d(startNav);
                fringe[0].heuristicCost = startNav.Distance2d(goalNav);

                // Contains NavPoints we've already searched once, so we don't repeat work
                // Ideally, this should be a tree, but even a dynamic array works wonders
                array<NavPoint> closed;

                // Until we run out of ideas
                while (fringe.Size() > 0)
                {
                    // Remove best partial Plan2 from fringe
                    Plan2 currentPlan2 = fringe[0];

                    {
                        // Replace root node w/ right-most leaf node
                        fringe[0] = fringe[fringe.Size()-1];
                        fringe.Pop();

                        // Let new root node trickle down until its cost is <= both its children's
                        int index = 0;
                        int childIndex1 = 1;
                        int childIndex2 = 2;
                        while (fringe.Size() > childIndex1) // Until new node is at bottom of heap
                        {
                            double cost = fringe[index].givenCost + fringe[index].heuristicCost;
                            double childCost1 = fringe[childIndex1].givenCost
                                              + fringe[childIndex1].heuristicCost;

                            // Find out which is cheapest: the node, or one of its children
                            int minIndex = index;

                            if (fringe.Size() > childIndex2)
                            {
                                double childCost2 = fringe[childIndex2].givenCost
                                                  + fringe[childIndex2].heuristicCost;

                                if (childCost2 < childCost1 && childCost2 < cost)
                                {
                                    minIndex = childIndex2;
                                }
                                else if (childCost1 < cost)
                                {
                                    minIndex = childIndex1;
                                }
                            }
                            else if (childCost1 < cost)
                            {
                                minIndex = childIndex1;
                            }

                            // Swap node w/ child, if needed
                            if (index != minIndex)
                            {
                                Plan2 temp = fringe[index];
                                fringe[index] = fringe[minIndex];
                                fringe[minIndex] = temp;

                                index = minIndex;
                                childIndex1 = 2 * index + 1;
                                childIndex2 = childIndex1 + 1;
                            }
                            else
                            {
                                break;
                            }
                        }
                    }

                    // If Plan2 reaches goal, we're done
                    NavPoint lastNav = currentPlan2.path[currentPlan2.path.Size()-1];
                    if (lastNav == goalNav)
                    {
                        //A_Log("(ZScript:Pathfinder2:A_Star) Path found!");   // DEBUG

                        // Does ZScript have garbage collection, or do I need to free memory?

                        // Invoker.path is a stack, so NavPoints go into it in reverse order
                        for (int i = currentPlan2.path.Size() - 1; i >= 0; --i)
                        {
                            invoker.path.Push(currentPlan2.path[i]);
                        }

                        return;
                    }

                    // Put last NavPoint in closed set
                    closed.Push(lastNav);

                    // Add Plan2s w/ one more NavPoint to fringe
                    int linkCount = lastNav.links.Size();
                    for (int i = 0; i < linkCount; ++i)
                    {
                        // Don't add Plan2s that include Navs in closed set
                        if (closed.Find(lastNav.links[i]) < closed.Size())
                            continue;

                        fringe.Push(New('Plan2'));
                        int index = fringe.Size()-1;

                        fringe[index].path.Copy(currentPlan2.path);
                        fringe[index].path.Push(lastNav.links[i]);

                        fringe[index].givenCost = currentPlan2.givenCost + lastNav.costs[i];
                        fringe[index].heuristicCost = lastNav.links[i].Distance2d(goalNav);

                        // Let new node bubble up until its cost is >= its parent's
                        while (index > 0)
                        {
                            int parentIndex = (index - 1) / 2;

                            double cost = fringe[index].givenCost + fringe[index].heuristicCost;
                            double parentCost = fringe[parentIndex].givenCost
                                              + fringe[parentIndex].heuristicCost;

                            // Swap node w/ parent, if needed
                            if (parentCost > cost)
                            {
                                Plan2 temp = fringe[index];
                                fringe[index] = fringe[parentIndex];
                                fringe[parentIndex] = temp;

                                index = parentIndex;
                            }
                            else
                            {
                                break;
                            }
                        }
                    }
                }

                //A_Log("\c[Yellow](ZScript:Pathfinder2:A_Star) Warning: No Path found!"); // DEBUG
            }
        }
    }
}